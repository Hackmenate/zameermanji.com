---
kind: article
created_at: 2012-04-23
title: Nanoc for Fun and Profit

---

When I began to redesign this website I decided that it should be powered by
a static site generator. The benefits of a static site generator are endless.
They enable me to write my posts in markdown, I can use vim and the shell for
common tasks, they are easy to modify, cheaper to host, etc.

After I evaluated all of the options I settled on [nanoc], a Ruby powered
static site generator.

## Why not Jekyll? ##
Why did I select nanoc and not [jekyll] or [octopress]? First, jekyll is not as
extensible as I hoped it would be. For example adding the ability to have HAML
layouts involves using the `jekyll_ext` gem which [monkey patches][jekyll_ext]
jekyll. I wasn't comfortable with monkey patching jekyll and went looking for a
more robust solution.

## The Power of Nanoc ##
Part of the appeal of nanoc is that it is only a static site compiler. Out of
the box it doesn't assume anything about site structure, purpose or contents of
the site. For this site I wanted to have the posts written in Pandoc flavored
markdown, static pages in HAML, layouts in HAML, stylesheets in Sass using the
Compass framework, my resume in LaTeX (converted to a PDF) and the dynamic
elements written in CoffeeScript.

All of my desired functionality was either supported out of the box by nanoc
or absurdly easy to add.

### Configuring Nanoc ###
Nanoc's behavior is defined by compilation rules and routing rules which are
defined in a `Rules` file using nanoc's DSL. These rules operate on items which
are files in the `content/` directory. Depending on where the item is located
and the file type, I can create rules that pass it through one or more filters
in the compile step, which transforms the item to another format. Using the same
information I can also determine the final filename and location in the
`output/` directory during the routing step.

### Compile Rules ###
For this blog I had to define multiple compile steps in order to get HAML ->
HTML, Pandoc -> HTML, SASS -> CSS, CoffeeScript -> JavaScript and LaTeX -> PDF
transformations. These transformations operate on the [filters][filters-list]
that nanoc ships with or filters that I [wrote][own-filters].

Lets look at the `compile` rule that creates the posts on this blog:

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
compile '/posts/*/' do
  ext = item[:extension].nil? ? nil : item[:extension].split('.').last
  if ext == 'pandoc'
    filter :pandoc
    filter :pygments
  else
    raise "Unknown ext: #{ext} with item: #{item.attributes}"
  end

  layout 'default'
end
~~~~~~~~~~~~~~~~~~~~~~~~

This rule operates on all the files that are in the `/posts/` directory of my
input files. Then, for each item I pass it through two filters. A `pandoc`
filter and a `pygments` filter. The first transforms the post in to HTML, and
the second adds syntax highlighting to the code bocks in the post. At the end
I just apply the `default` layout to the item. This produces the final HTML of
the page.

### Filters ###

In the above rule I used two filters that did not ship with Nanoc. I had to
create them because Nanoc does not ship with a Pandoc filter and I had to then
create my own syntax highlighting filter because I could not get the builtin one
to work. Lets look at the `pandoc` filter first:

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
require 'pandoc-ruby'

class PandocFilter < Nanoc3::Filter
  identifier :pandoc
  type :text

  def run(content, params = {})
    ::PandocRuby.convert(content, 'smart')
  end
end
~~~~~~~~~~~~~~~~~~~~~~~~

Nanoc filters are *stupidly* easy to write. All you need to do is create a class
that inherits from `Nanoc3::Filter`, give it a unique identifier and define
a `run` method which takes in a strong of content for you to transform. You just
need to return the result of the transformation. To write my `pandoc` filter
I used the wonderful [pandoc-ruby][pandoc-ruby] gem which wraps around the
`pandoc` executable.

Of course not all filters are going to be this simple or easier to write. Adding
syntax highlighting was significantly harder. My `pygments` filter at the time
of writing is below:

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
require 'pygments.rb'
require 'hpricot'
require 'cgi'

class PygmentsFilter < Nanoc3::Filter
  identifier :pygments
  type :text

  def run(content, params = {})
    post = Hpricot(content)
    code_blocks = post.search('pre.ruby code')
    code_blocks.each do |code_block|
      code = code_block.inner_html
      code = CGI.unescapeHTML(code)
      code = ::Pygments.highlight(code, :lexer => 'ruby', :options => {:lineseparator => '<br>', :encoding => 'utf-8'})
      code_block.parent.swap code
    end

    post.to_html

  end
end
~~~~~~~~~~~~~~~~~~~~~~~~

This filter assumes that the input is produced by my `pandoc` filter. It uses
the wonderful `Hpricot` library to parse the input. It then takes the content of
the code blocks created by Pandoc and sends it to Pygments. The resulting output
replaces the block created by Pandoc. The above code only highlights Ruby, but
it is trivial to extend to all the other programing languages that Pygments
supports.


## Routing Rules ##
After compiling items the next rule applied is the `route` rules. The `route`
rules define where an item should be placed in the output directory and what
filename it should have. Since the `Rules` file is pure Ruby you can leverage
all of ruby to create the URL scheme required. Here is the `route` rule for the
posts on this site.

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
route '/posts/*/' do
  date = item[:created_at]
  raise "No Posted Date!" if date.nil?

  slug = item[:title].to_slug

  "/posts/#{date.year}/#{date.month}/#{date.day}/#{slug}/index.html"

end
~~~~~~~~~~~~~~~~~~~~~~~~

This rule simply returns the desired path and filename of the item in the output
directory. Here I use the [to_slug][to_slug] gem to help me generate a slug in
the URL from the post title.

*Like this post? Follow me on [Twitter][twitter].*

[nanoc]: http://nanoc.stoneship.org/
[dsl]: http://nanoc.stoneship.org/docs/api/3.2/Nanoc3/CompilerDSL.html
[pandoc]: http://johnmacfarlane.net/pandoc/
[pygments]: http://pygments.org/
[pandoc-ruby]: https://github.com/alphabetum/pandoc-ruby
[filters-list]: http://nanoc.stoneship.org/docs/4-basic-concepts/#filters
[own-filter]: http://nanoc.stoneship.org/docs/5-advanced-concepts/#writing-filters
[twitter]: http://www.twitter.com/zmanji
[to_slug]: http://rubygems.org/gems/to_slug
[jekyll]: https://github.com/mojombo/jekyll
[jekyll_ext]: https://github.com/rfelix/jekyll_ext/blob/master/lib/aop.rb
[docs]: http://nanoc.stoneship.org/docs/api/3.3/
