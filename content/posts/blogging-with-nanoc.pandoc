---
kind: article
created_at: 2012-04-23
title: Blogging With Nanoc

---

I chose to move my site to a static site generator because I was not satisfied
with the simplicity and customizability of other blogging platforms. I evaluated
a bunch of static site generators and finally settled on [nanoc][nanoc] Ruby
powered static site generator written by [Denis Defreyne][stoneship].

## Why Nanoc? ##
Why did I select nanoc over more popular static site generators such as
[jekyll][jekyll]?

### Jekyll ###
Jekyll at first seems to be the perfect candidate: there are lots of users and
markdown is supported out of the box. However Jekyll has lots of problems once
you start using it. First it can't support HAML in layouts. Adding support for HAML
either involves [invoking the shell](http://mikeferrier.com/2011/04/29/blogging-with-jekyll-haml-sass-and-jammit/)
every time you compile which sort of defeats the point of a ruby based site compiler
or [using a gem](http://www.duckpuppy.com/blog/2011/10/31/using-haml-with-jekyll)
that [monkey patches](https://github.com/rfelix/jekyll_ext/blob/master/lib/aop.rb)
the shit out of Jekyll. The amount of work involved to get HAML layouts is not
the sign of an easy to extend solution.

Secondly, it seems that Jekyll development has slowed and I don't see future
improvements coming from the project. As of writing there are 251 open issues on
the project on GitHub explaining all sorts of problems and 52 open pull
requests. It makes sense that the project is in this state considering the
primary author is one of GitHub's co-founders and probably has a lot of other
things to do.

### Hyde ###
Hyde looked like a very good candidate as well. (Complete This Section....)


## The Power of Nanoc ##
Part of the appeal of nanoc is that it is simply a compiler. Out of the box it
doesn't assume anything and has extensive documentation about extending it. For
this site I choose to be different, where I would have posts written in Pandoc
flavored markdown, static pages in HAML, layouts in HAML, stylesheets in Sass
using the Compass framework, my resume in LaTeX (converted to a PDF) and the
dynamic elements written in CoffeeScript.

All of my desired functionality was either supported out of the box by nanoc
or absurdly easy to add.

### Configuring Nanoc ###
Nanoc's behavior is defined by compilation rules and routing rules which are
defined in a `Rules` file using nanoc's DSL. These rules operate on items which
are files in the `content/` directory. Depending on where the item is located
and the file type, I can create rules that pass it through one or more filters
in the compile step, which transforms the item to another format. Using the same
information I can also determine the final filename and location in the routing
step.

### Compile Rules ###
For this blog I had to define multiple compile steps in order to get HAML ->
HTML, Pandoc -> HTML, SASS -> CSS, CoffeeScript -> JavaScript and LaTeX -> PDF
transformations. These transformations operate on the [filters][filters-list]
that nanoc ships with or filters that I [wrote][own-filters].

Lets look at the `compile` rule that creates the posts on this blog:

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
compile '/posts/*/' do
  ext = item[:extension].nil? ? nil : item[:extension].split('.').last
  if ext == 'pandoc'
    filter :pandoc
    filter :pygments
  else
    raise "Unknown ext: #{ext} with item: #{item.attributes}"
  end

  layout 'default'
end
~~~~~~~~~~~~~~~~~~~~~~~~

This rule operates on all the files that are in the `/posts/` directory of my
input files. Then, for each item I pass it through two filters. A `pandoc`
filter and a `pygments` filter. The first transforms the post in to HTML, and
the second adds syntax highlighting to the code bocks in the post. At the end
I just apply the `default` layout to the item. This produces the final HTML of
the page.

In this rule I could have applied as many filters as I wanted or needed. I could
have also applied them conditionally as well based on some metadata that I added
to the item. The beauty of nanoc is that filters are very simple to use and
chain and I also have the full power of Ruby at my fingertips so I can make
whatever transformations that are required.

### Filters ###

In the above rule I used two filters that did not ship with Nanoc. I had to
create them because Nanoc does not ship with a Pandoc filter and I had to then
create my own syntax highlighting filter because I could not get the builtin one
to work. Lets look at the `pandoc` filter first:

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
require 'pandoc-ruby'

class PandocFilter < Nanoc3::Filter
  identifier :pandoc
  type :text

  def run(content, params = {})
    ::PandocRuby.convert(content, 'smart')
  end
end
~~~~~~~~~~~~~~~~~~~~~~~~

Nanoc filters are *stupidly* easy to write. All you need to do is create a class
that inherits from `Nanoc3::Filter`, give it a unique identifier and define
a `run` method which takes in a strong of content for you to transform. You just
need to return the result of the transformation. To write my `pandoc` filter
I used the wonderful [pandoc-ruby][pandoc-ruby] gem which wraps around the
`pandoc` executable.

Of course not all filters are going to be this simple or easier to write. Adding
syntax highlighting was significantly harder. My `pygments` filter at the time
of writing is below:

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
require 'pygments.rb'
require 'hpricot'
require 'cgi'

class PygmentsFilter < Nanoc3::Filter
  identifier :pygments
  type :text

  def run(content, params = {})
    post = Hpricot(content)
    code_blocks = post.search('pre.ruby code')
    code_blocks.each do |code_block|
      code = code_block.inner_html
      code = CGI.unescapeHTML(code)
      code = ::Pygments.highlight(code, :lexer => 'ruby', :options => {:lineseparator => '<br>', :encoding => 'utf-8'})
      code_block.parent.swap code
    end

    post.to_html

  end
end
~~~~~~~~~~~~~~~~~~~~~~~~

This filter assumes that the input is produced by my `pandoc` filter. It uses
the wonderful `Hpricot` library to parse the input. It then takes the content of
the code blocks created by Pandoc and sends it to Pygments. The resulting output
replaces the block created by Pandoc. The above code only highlights Ruby, but
it is trivial to extend to all the other programing languages that Pygments
supports.


## Routing Rules ##
After compiling items the next rule applied is the `route` rules. The `route`
rules define where an item should be placed in the output directory and what
filename it should have. Since the `Rules` file is pure Ruby you can leverage
all of ruby to create the URL scheme required. Here is the `route` rule for the
posts on this site.

~~~~~~~~~~~~~~~~~~~~~~~~ {.ruby}
route '/posts/*/' do
  date = item[:created_at]
  raise "No Posted Date!" if date.nil?

  slug = item[:title].to_slug

  "/posts/#{date.year}/#{date.month}/#{date.day}/#{slug}/index.html"

end
~~~~~~~~~~~~~~~~~~~~~~~~

This rule simply returns the desired path and filename of the item in the output
directory. Here I use the [to_slug][to_slug] gem to help me generate a slug in
the URL from the post title.

*Like this post? Follow me on [Twitter][twitter].*

[nanoc]: http://nanoc.stoneship.org/
[dsl]: http://nanoc.stoneship.org/docs/api/3.2/Nanoc3/CompilerDSL.html
[pandoc]: http://johnmacfarlane.net/pandoc/
[pygments]: http://pygments.org/
[pandoc-ruby]: https://github.com/alphabetum/pandoc-ruby
[filters-list]: http://nanoc.stoneship.org/docs/4-basic-concepts/#filters
[own-filter]: http://nanoc.stoneship.org/docs/5-advanced-concepts/#writing-filters
[twitter]: http://www.twitter.com/zmanji
[to_slug]: http://rubygems.org/gems/to_slug
[jekyll]: https://github.com/mojombo/jekyll
[octopress]: http://octopress.org/docs/
[mhyee-post]: http://mhyee.com/blog/nanoc.html
[mhyee]: http://mhyee.com
[stoneship]: http://stoneship.org/
